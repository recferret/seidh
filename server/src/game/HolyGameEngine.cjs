// Generated by Haxe 4.3.4
(function ($hx_exports, $global) { "use strict";
$hx_exports["engine"] = $hx_exports["engine"] || {};
$hx_exports["engine"]["base"] = $hx_exports["engine"]["base"] || {};
$hx_exports["engine"]["base"]["core"] = $hx_exports["engine"]["base"]["core"] || {};
;$hx_exports["engine"]["holy"] = $hx_exports["engine"]["holy"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = true;
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
	static random(x) {
		if(x <= 0) {
			return 0;
		} else {
			return Math.floor(Math.random() * x);
		}
	}
}
Std.__name__ = true;
class StringTools {
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class engine_base_EntityShape {
	constructor(width,height,rectOffsetX,rectOffsetY) {
		if(rectOffsetY == null) {
			rectOffsetY = 0;
		}
		if(rectOffsetX == null) {
			rectOffsetX = 0;
		}
		this.rotation = 0.0;
		this.width = width;
		this.height = height;
		if(rectOffsetX == 0 && rectOffsetY == 0) {
			this.rectOffsetX = width / 2 | 0;
			this.rectOffsetY = height / 2 | 0;
		} else {
			this.rectOffsetX = rectOffsetX;
			this.rectOffsetY = rectOffsetY;
		}
	}
	toRect(x,y,side) {
		let sideOffset = side == 2 ? 0 : -this.width + 45;
		return new engine_base_geometry_Rectangle(x + this.rectOffsetX + sideOffset,y + this.rectOffsetY,this.width,this.height,0);
	}
	toJson() {
		return JSON.stringify({ width : this.width, height : this.height, rectOffsetX : this.rectOffsetX, rectOffsetY : this.rectOffsetY, rotation : this.rotation});
	}
}
engine_base_EntityShape.__name__ = true;
Object.assign(engine_base_EntityShape.prototype, {
	__class__: engine_base_EntityShape
});
class engine_base_BaseObjectEntity {
	constructor(struct) {
		this.x = struct.x;
		this.y = struct.y;
		this.entityType = struct.entityType;
		this.entityShape = struct.entityShape;
		this.id = struct.id;
		this.health = struct.health;
		this.dodgeChance = struct.dodgeChance;
		this.ownerId = struct.ownerId;
		if(struct.rotation != null) {
			this.rotation = struct.rotation;
		} else {
			this.rotation = 0;
		}
		this.movement = struct.entityMovementStruct;
		this.actions = struct.entityActionStruct;
	}
	toJson() {
		return JSON.stringify({ id : this.id, ownerId : this.ownerId, entityType : this.entityType, entityShape : this.entityShape, x : this.x, y : this.y, health : this.health, dodgeChance : this.dodgeChance, rotation : this.rotation, movement : this.movement, actions : this.actions});
	}
}
engine_base_BaseObjectEntity.__name__ = true;
Object.assign(engine_base_BaseObjectEntity.prototype, {
	__class__: engine_base_BaseObjectEntity
});
class engine_base_PlayerInputCommand {
	constructor(inputType,movAngle,playerId,index) {
		this.inputType = inputType;
		this.movAngle = movAngle;
		this.playerId = playerId;
		this.index = index;
	}
}
engine_base_PlayerInputCommand.__name__ = true;
Object.assign(engine_base_PlayerInputCommand.prototype, {
	__class__: engine_base_PlayerInputCommand
});
class engine_base_InputCommandEngineWrapped {
	constructor(playerInputCommand,tick) {
		this.playerInputCommand = playerInputCommand;
		this.tick = tick;
	}
}
engine_base_InputCommandEngineWrapped.__name__ = true;
Object.assign(engine_base_InputCommandEngineWrapped.prototype, {
	__class__: engine_base_InputCommandEngineWrapped
});
class engine_base_MathUtils {
	static angleBetweenPoints(point1,point2) {
		return Math.atan2(point2.y - point1.y,point2.x - point1.x);
	}
	static degreeToRads(degrees) {
		return Math.PI / 180 * degrees;
	}
	static radsToDegree(rads) {
		return rads * (180 / Math.PI);
	}
	static normalizeAngle(rads) {
		rads %= 2 * Math.PI;
		if(rads >= 0) {
			return rads;
		} else {
			return rads + 2 * Math.PI;
		}
	}
	static rotatePointAroundCenter(x,y,cx,cy,r) {
		let cos = Math.cos(r);
		let sin = Math.sin(r);
		return new engine_base_geometry_Point(cos * (x - cx) - sin * (y - cy) + cx,cos * (y - cy) + sin * (x - cx) + cy);
	}
	static lineToLineIntersection(lineA,lineB) {
		let numA = (lineB.x2 - lineB.x1) * (lineA.y1 - lineB.y1) - (lineB.y2 - lineB.y1) * (lineA.x1 - lineB.x1);
		let numB = (lineA.x2 - lineA.x1) * (lineA.y1 - lineB.y1) - (lineA.y2 - lineA.y1) * (lineA.x1 - lineB.x1);
		let deNom = (lineB.y2 - lineB.y1) * (lineA.x2 - lineA.x1) - (lineB.x2 - lineB.x1) * (lineA.y2 - lineA.y1);
		if(deNom == 0) {
			return false;
		}
		let uA = numA / deNom;
		let uB = numB / deNom;
		if(uA >= 0 && uA <= 1 && uB >= 0) {
			return uB <= 1;
		} else {
			return false;
		}
	}
	static differ(a,b,error) {
		return Math.abs(a - b) > (error == 0 ? 1 : error);
	}
}
engine_base_MathUtils.__name__ = true;
class engine_base_EngineUtils {
	static HashString(str) {
		let strLen = str.length;
		if(strLen == 0) {
			return 0;
		}
		let hc = 0;
		let _g = 0;
		let _g1 = strLen;
		while(_g < _g1) {
			let i = _g++;
			hc = ((hc << 5) - hc | 0) + HxOverrides.cca(str,i) | 0;
		}
		return hc;
	}
}
engine_base_EngineUtils.__name__ = true;
var engine_base_core_EngineMode = $hxEnums["engine.base.core.EngineMode"] = { __ename__:true,__constructs__:null
	,Client: {_hx_name:"Client",_hx_index:0,__enum__:"engine.base.core.EngineMode",toString:$estr}
	,Server: {_hx_name:"Server",_hx_index:1,__enum__:"engine.base.core.EngineMode",toString:$estr}
};
engine_base_core_EngineMode.__constructs__ = [engine_base_core_EngineMode.Client,engine_base_core_EngineMode.Server];
class engine_base_core_BaseEngine {
	constructor(engineMode,mainEntityManager) {
		if(engine_base_core_BaseEngine._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(engineMode,mainEntityManager);
	}
	_hx_constructor(engineMode,mainEntityManager) {
		this.coldInputCommands = [];
		this.coldInputCommandsTreshhold = 10;
		this.ticksSinceLastPop = 0;
		this.hotInputCommands = [];
		this.removeMainEntityQueue = [];
		this.addMainEntityQueue = [];
		this.validatedInputCommands = [];
		this.playerToEntityMap = new haxe_ds_StringMap();
		this.engineMode = engineMode;
		this.mainEntityManager = mainEntityManager;
		let _gthis = this;
		let loop = function(dt,tick) {
			_gthis.tick = tick;
			if(_gthis.ticksSinceLastPop == _gthis.coldInputCommandsTreshhold) {
				_gthis.ticksSinceLastPop = 0;
				_gthis.coldInputCommands.shift();
			}
			_gthis.ticksSinceLastPop++;
			_gthis.processCreateEntityQueue();
			_gthis.processRemoveEntityQueue();
			if(_gthis.hotInputCommands.length > 0) {
				_gthis.processInputCommands(_gthis.hotInputCommands);
				_gthis.hotInputCommands = [];
			}
			_gthis.engineLoopUpdate(dt);
			if(_gthis.postLoopCallback != null) {
				_gthis.postLoopCallback();
			}
			_gthis.validatedInputCommands = [];
		};
		this.gameLoop = new engine_base_core_GameLoop(loop);
		this.okLoopTime = 1000 / this.gameLoop.targetFps | 0;
	}
	createMainEntity(entity,fireCallback) {
		if(fireCallback == null) {
			fireCallback = false;
		}
		this.addMainEntityQueue.push({ entity : entity, fireCallback : fireCallback});
	}
	removeMainEntity(entityId) {
		this.removeMainEntityQueue.push(entityId);
	}
	getMainEntityById(id) {
		return this.mainEntityManager.getEntityById(id);
	}
	getMainEntityIdByOwnerId(id) {
		return this.playerToEntityMap.h[id];
	}
	getMainEntityByOwnerId(id) {
		return this.mainEntityManager.getEntityById(this.playerToEntityMap.h[id]);
	}
	updateEntitiesByServer(minEntities) {
		let _g = 0;
		while(_g < minEntities.length) {
			let minEntity = minEntities[_g];
			++_g;
			let entity = this.mainEntityManager.entities.get(minEntity.id);
			if(entity != null) {
				entity.setX(minEntity.x);
				entity.setY(minEntity.y);
				entity.currentDirectionSide = minEntity.side;
			}
		}
	}
	setEntityNextActionToPerform(entityId,entityActionType) {
		let entity = this.mainEntityManager.getEntityById(entityId);
		if(entity != null) {
			entity.setNextActionToPerform(entityActionType);
		}
	}
	getMainEntities() {
		return this.mainEntityManager.entities;
	}
	getMainEntitiesChanged() {
		let result = [];
		let jsIterator = this.mainEntityManager.entities.values();
		let _g_jsIterator = jsIterator;
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = _g_jsIterator.next();
			let entity = v;
			if(entity.isChanged()) {
				result.push(entity);
			}
		}
		return result;
	}
	processCreateEntityQueue() {
		let _g = 0;
		let _g1 = this.addMainEntityQueue;
		while(_g < _g1.length) {
			let queueTask = _g1[_g];
			++_g;
			this.mainEntityManager.add(queueTask.entity);
			let this1 = this.playerToEntityMap;
			let key = queueTask.entity.getOwnerId();
			let value = queueTask.entity.getId();
			this1.h[key] = value;
			if(queueTask.fireCallback) {
				if(this.createMainEntityCallback != null) {
					this.createMainEntityCallback(queueTask.entity);
				}
			}
		}
		this.addMainEntityQueue = [];
	}
	processRemoveEntityQueue() {
		let _g = 0;
		let _g1 = this.removeMainEntityQueue;
		while(_g < _g1.length) {
			let entityId = _g1[_g];
			++_g;
			let entity = this.mainEntityManager.getEntityById(entityId);
			if(entity != null) {
				if(this.deleteMainEntityCallback != null) {
					this.deleteMainEntityCallback(entity);
				}
				let this1 = this.playerToEntityMap;
				let key = entity.getOwnerId();
				let _this = this1;
				if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
					delete(_this.h[key]);
				}
				this.mainEntityManager.remove(entity.getId());
			}
		}
		this.removeMainEntityQueue = [];
	}
	checkLocalMovementInputAllowance(entityId,playerInputType) {
		let entity = this.mainEntityManager.getEntityById(entityId);
		if(entity == null) {
			return false;
		} else if(entity.checkLocalMovementInput()) {
			return entity.canPerformMove(playerInputType);
		} else {
			return false;
		}
	}
	checkLocalActionInputAllowance(entityId,playerInputType) {
		let entity = this.mainEntityManager.getEntityById(entityId);
		if(entity == null) {
			return false;
		} else if(entity.checkLocalActionInputAndPrepare(playerInputType)) {
			return entity.canPerformAction(playerInputType);
		} else {
			return false;
		}
	}
	addInputCommandServer(struct) {
		let entityId = this.getMainEntityIdByOwnerId(struct.playerId);
		let allow = false;
		if(struct.inputType == 1) {
			allow = this.checkLocalMovementInputAllowance(entityId,struct.inputType);
		} else {
			allow = this.checkLocalActionInputAllowance(entityId,struct.inputType);
		}
		if(allow) {
			this.addInputCommandClient(new engine_base_PlayerInputCommand(struct.inputType,struct.movAngle,struct.playerId));
		}
	}
	addInputCommandClient(playerInputCommand) {
		if(playerInputCommand.inputType != null && playerInputCommand.playerId != null) {
			let wrappedCommand = new engine_base_InputCommandEngineWrapped(playerInputCommand,this.tick);
			this.hotInputCommands.push(wrappedCommand);
			this.coldInputCommands.push(wrappedCommand);
		}
	}
	destroy() {
		this.gameLoop.stopLoop();
		this.mainEntityManager.destroy();
		this.postLoopCallback = null;
		this.createMainEntityCallback = null;
		this.deleteMainEntityCallback = null;
		this.customDestroy();
	}
}
$hx_exports["engine"]["base"]["core"]["BaseEngine"] = engine_base_core_BaseEngine;
engine_base_core_BaseEngine.__name__ = true;
Object.assign(engine_base_core_BaseEngine.prototype, {
	__class__: engine_base_core_BaseEngine
});
class engine_base_core_Loop {
}
engine_base_core_Loop.__name__ = true;
engine_base_core_Loop.__isInterface__ = true;
Object.assign(engine_base_core_Loop.prototype, {
	__class__: engine_base_core_Loop
});
class engine_base_core_GameLoop {
	constructor(update) {
		this.targetFps = 10;
		this.gameLoop = new engine_base_core_DummyJsLoop(update,this.targetFps);
	}
	stopLoop() {
		this.gameLoop.stopLoop();
	}
}
$hx_exports["engine"]["base"]["core"]["GameLoop"] = engine_base_core_GameLoop;
engine_base_core_GameLoop.__name__ = true;
Object.assign(engine_base_core_GameLoop.prototype, {
	__class__: engine_base_core_GameLoop
});
class engine_base_core_DummyJsLoop {
	constructor(update,targetFps) {
		this.active = true;
		this.delta = 0.0;
		this.previous = Date.now();
		this.tick = 0;
		this.targetFPSMillis = Math.floor(1000 / targetFps);
		this.update = update;
		this.loop();
	}
	stopLoop() {
		this.active = false;
	}
	loop() {
		if(this.active) {
			haxe_Timer.delay($bind(this,this.loop),this.targetFPSMillis);
			let now = Date.now();
			this.delta = (now - this.previous) / 1000;
			this.update(this.delta,this.tick);
			this.previous = now;
			this.tick++;
		}
	}
}
engine_base_core_DummyJsLoop.__name__ = true;
engine_base_core_DummyJsLoop.__interfaces__ = [engine_base_core_Loop];
Object.assign(engine_base_core_DummyJsLoop.prototype, {
	__class__: engine_base_core_DummyJsLoop
});
class engine_base_entity_BaseEntityManager {
	constructor() {
		this.entities = new Map();
	}
	destroy() {
		this.entities.clear();
		this.updateCallback = null;
	}
	getChangedEntities() {
		let result = [];
		this.entities.forEach(function(value,key,map) {
			if(value.isChanged()) {
				result.push(value);
			}
		});
		return result;
	}
	add(entity) {
		this.entities.set(entity.getId(),entity);
	}
	remove(id) {
		this.entities.delete(id);
	}
	getEntityById(id) {
		return this.entities.get(id);
	}
}
engine_base_entity_BaseEntityManager.__name__ = true;
Object.assign(engine_base_entity_BaseEntityManager.prototype, {
	__class__: engine_base_entity_BaseEntityManager
});
class engine_base_entity_GameEntityCustomUpdate {
}
engine_base_entity_GameEntityCustomUpdate.__name__ = true;
engine_base_entity_GameEntityCustomUpdate.__isInterface__ = true;
Object.assign(engine_base_entity_GameEntityCustomUpdate.prototype, {
	__class__: engine_base_entity_GameEntityCustomUpdate
});
class engine_base_entity_GameEntityCustomCollide {
}
engine_base_entity_GameEntityCustomCollide.__name__ = true;
engine_base_entity_GameEntityCustomCollide.__isInterface__ = true;
Object.assign(engine_base_entity_GameEntityCustomCollide.prototype, {
	__class__: engine_base_entity_GameEntityCustomCollide
});
class engine_base_entity_EngineBaseGameEntity {
	constructor(baseObjectEntity) {
		this.rangedActions = [];
		this.meleeActions = [];
		this.lastLocalDefendInputCheck = 0.0;
		this.lastLocalRangedInputCheck = 0.0;
		this.lastLocalMeleeAttackInputCheck = 0.0;
		this.isActing = false;
		this.dy = 0.0;
		this.dx = 0.0;
		this.lastLocalMovementInputCheck = 0.0;
		this.isRunning = false;
		this.isWalking = false;
		this.currentDirectionSide = 2;
		this.isCollides = true;
		this.isAlive = true;
		this.baseObjectEntity = baseObjectEntity;
		this.isPlayer = [1,2].includes(this.baseObjectEntity.entityType);
		if(baseObjectEntity.id == null) {
			this.baseObjectEntity.id = uuid_Uuid.short();
		}
		if(baseObjectEntity.ownerId == null) {
			this.baseObjectEntity.ownerId = uuid_Uuid.short();
		}
		this.currentVitality = this.baseObjectEntity.movement.vitality;
		let _g = 0;
		let _g1 = this.baseObjectEntity.actions;
		while(_g < _g1.length) {
			let action = _g1[_g];
			++_g;
			switch(action.actionType) {
			case 1:
				this.meleeActions.push(action);
				break;
			case 2:
				this.meleeActions.push(action);
				break;
			case 3:
				this.meleeActions.push(action);
				break;
			case 4:
				this.runAttackAction = action;
				break;
			case 5:
				this.rangedActions.push(action);
				break;
			case 6:
				this.rangedActions.push(action);
				break;
			case 7:
				this.defendAction = action;
				break;
			}
		}
	}
	update(dt) {
		this.lastDeltaTime = dt;
		if(this.customUpdate != null) {
			this.customUpdate.onUpdate();
		}
		if(this.targetObjectEntity != null) {
			this.moveToTarget();
		}
		if(this.customUpdate != null) {
			this.customUpdate.postUpdate();
		}
		this.renegerateVitality();
		this.updateHash();
	}
	getBodyRectangle() {
		let shapeWidth = this.baseObjectEntity.entityShape.width;
		let shapeHeight = this.baseObjectEntity.entityShape.height;
		let rectOffsetX = this.baseObjectEntity.entityShape.rectOffsetX;
		let rectOffsetY = this.baseObjectEntity.entityShape.rectOffsetY;
		let x = this.baseObjectEntity.x;
		let y = this.baseObjectEntity.y;
		return new engine_base_geometry_Rectangle(x + rectOffsetX,y + rectOffsetY,shapeWidth,shapeHeight,this.baseObjectEntity.entityShape.rotation);
	}
	getVirtualBodyRectangleInFuture(ticks) {
		let cachedPositionX = this.baseObjectEntity.x;
		let cachedPositionY = this.baseObjectEntity.y;
		let _g = 0;
		let _g1 = ticks;
		while(_g < _g1) {
			let i = _g++;
		}
		let resultingRect = this.getBodyRectangle();
		this.baseObjectEntity.x = cachedPositionX;
		this.baseObjectEntity.y = cachedPositionY;
		return resultingRect;
	}
	getForwardLookingLine(lineLength) {
		let rect = this.getBodyRectangle();
		let x = rect.getCenter().x;
		let y = rect.getCenter().y;
		return { p1 : rect.getCenter(), p2 : engine_base_MathUtils.rotatePointAroundCenter(x + lineLength,y,x,y,this.baseObjectEntity.rotation)};
	}
	collides(isCollides) {
		this.isCollides = isCollides;
		if(this.customCollide != null) {
			this.customCollide.onCollide();
		}
	}
	isChanged() {
		return this.previousTickHash != this.currentTickHash;
	}
	updateHash() {
		let hash = this.updateHashImpl();
		if(this.previousTickHash == null && this.currentTickHash == null) {
			this.previousTickHash = hash;
			this.currentTickHash = hash;
		} else {
			this.previousTickHash = this.currentTickHash;
			this.currentTickHash = hash;
		}
	}
	setTargetObject(targetObjectEntity) {
		this.targetObjectEntity = targetObjectEntity;
	}
	hasTargetObject() {
		return this.targetObjectEntity != null;
	}
	distanceBetweenTarget() {
		if(this.hasTargetObject()) {
			let _this = this.getBodyRectangle().getCenter();
			let p = this.targetObjectEntity.getBodyRectangle().getCenter();
			let dx = _this.x - p.x;
			let dy = _this.y - p.y;
			return Math.sqrt(dx * dx + dy * dy);
		} else {
			return 0;
		}
	}
	renegerateVitality() {
		if(this.baseObjectEntity.movement.canRun && !this.isWalking && !this.isRunning) {
			this.currentVitality += this.baseObjectEntity.movement.vitalityRegenPerSec;
		}
	}
	determenisticMove() {
		let speed = this.baseObjectEntity.movement.walkSpeed;
		if(this.baseObjectEntity.movement.canRun && this.currentVitality > 0) {
			this.currentVitality -= this.baseObjectEntity.movement.vitalityConsumptionPerSec;
			speed = this.baseObjectEntity.movement.runSpeed;
			this.isRunning = true;
			this.isWalking = false;
		} else {
			this.isRunning = false;
			this.isWalking = true;
		}
		this.dx = speed * Math.cos(this.baseObjectEntity.rotation);
		this.dy = speed * Math.sin(this.baseObjectEntity.rotation);
		this.currentDirectionSide = this.baseObjectEntity.x + this.dx > this.baseObjectEntity.x ? 2 : 1;
		this.baseObjectEntity.x += this.dx | 0;
		this.baseObjectEntity.y += this.dy | 0;
	}
	moveToTarget() {
		let _this = this.getBodyRectangle().getCenter();
		let p = this.targetObjectEntity.getBodyRectangle().getCenter();
		let dx = _this.x - p.x;
		let dy = _this.y - p.y;
		let dist = Math.sqrt(dx * dx + dy * dy);
		if(dist > this.targetObjectEntity.getFullEntity().entityShape.width) {
			let angleBetweenEntities = engine_base_MathUtils.angleBetweenPoints(this.getBodyRectangle().getCenter(),this.targetObjectEntity.getBodyRectangle().getCenter());
			let speed = this.baseObjectEntity.movement.walkSpeed;
			this.dx = speed * Math.cos(angleBetweenEntities) * this.lastDeltaTime;
			this.dy = speed * Math.sin(angleBetweenEntities) * this.lastDeltaTime;
			this.currentDirectionSide = this.baseObjectEntity.x + this.dx > this.baseObjectEntity.x ? 2 : 1;
			this.baseObjectEntity.x += this.dx | 0;
			this.baseObjectEntity.y += this.dy | 0;
		}
	}
	checkLocalMovementInput() {
		let now = HxOverrides.now() / 1000;
		if(this.lastLocalMovementInputCheck == 0 || this.lastLocalMovementInputCheck + this.baseObjectEntity.movement.movementDelay < now) {
			this.lastLocalMovementInputCheck = now;
			return true;
		} else {
			return false;
		}
	}
	checkLocalActionInputAndPrepare(playerInputType) {
		let now = HxOverrides.now() / 1000;
		let hardcodedActionInputDelay = 1;
		let allow = false;
		if(playerInputType == 2) {
			if(this.lastLocalMeleeAttackInputCheck == 0 || this.lastLocalMeleeAttackInputCheck + hardcodedActionInputDelay < now) {
				this.lastLocalMeleeAttackInputCheck = now;
				allow = true;
				this.actionToPerform = this.isRunning ? this.runAttackAction : this.meleeActions[Std.random(this.meleeActions.length)];
			}
		} else if(playerInputType == 3) {
			if(this.lastLocalRangedInputCheck == 0 || this.lastLocalRangedInputCheck + hardcodedActionInputDelay < now) {
				this.lastLocalRangedInputCheck = now;
				allow = true;
				this.actionToPerform = this.rangedActions[Std.random(this.rangedActions.length)];
			}
		} else if(playerInputType == 4) {
			if(this.lastLocalDefendInputCheck == 0 || this.lastLocalDefendInputCheck + hardcodedActionInputDelay < now) {
				this.lastLocalDefendInputCheck = now;
				allow = true;
				this.actionToPerform = this.defendAction;
			}
		}
		return allow;
	}
	setNextActionToPerform(entityActionType) {
		this.isActing = true;
		switch(entityActionType) {
		case 1:
			this.actionToPerform = this.meleeActions[0];
			break;
		case 2:
			this.actionToPerform = this.meleeActions[1];
			break;
		case 3:
			this.actionToPerform = this.meleeActions[2];
			break;
		case 4:
			this.actionToPerform = this.runAttackAction;
			break;
		case 5:
			this.actionToPerform = this.rangedActions[0];
			break;
		case 6:
			this.actionToPerform = this.rangedActions[1];
			break;
		case 7:
			this.actionToPerform = this.defendAction;
			break;
		}
	}
	addHealth(add) {
		this.baseObjectEntity.health += add;
	}
	subtractHealth(subtract) {
		this.baseObjectEntity.health -= subtract;
		if(this.baseObjectEntity.health < 0) {
			this.baseObjectEntity.health = 0;
		}
		return this.baseObjectEntity.health;
	}
	getFullEntity() {
		return this.baseObjectEntity;
	}
	getMinEntity() {
		let minEntity = { id : this.baseObjectEntity.id, x : this.baseObjectEntity.x, y : this.baseObjectEntity.y, side : this.currentDirectionSide};
		return minEntity;
	}
	getX() {
		return this.baseObjectEntity.x;
	}
	getY() {
		return this.baseObjectEntity.y;
	}
	getId() {
		return this.baseObjectEntity.id;
	}
	getEntityType() {
		return this.baseObjectEntity.entityType;
	}
	getOwnerId() {
		return this.baseObjectEntity.ownerId;
	}
	getRotation() {
		return this.baseObjectEntity.rotation;
	}
	getCurrentActionRect() {
		return this.actionToPerform.shape.toRect(this.baseObjectEntity.x,this.baseObjectEntity.y,this.currentDirectionSide);
	}
	getHealth() {
		return this.baseObjectEntity.health;
	}
	setX(x) {
		this.baseObjectEntity.x = x;
	}
	setY(y) {
		this.baseObjectEntity.y = y;
	}
	setRotation(r) {
		this.baseObjectEntity.rotation = r;
	}
}
engine_base_entity_EngineBaseGameEntity.__name__ = true;
Object.assign(engine_base_entity_EngineBaseGameEntity.prototype, {
	__class__: engine_base_entity_EngineBaseGameEntity
});
class engine_base_geometry_Line {
	constructor(x1,y1,x2,y2) {
		if(y2 == null) {
			y2 = 0;
		}
		if(x2 == null) {
			x2 = 0;
		}
		if(y1 == null) {
			y1 = 0;
		}
		if(x1 == null) {
			x1 = 0;
		}
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
	}
	getMidPoint() {
		return new engine_base_geometry_Point((this.x1 + this.x2) / 2,(this.y1 + this.y2) / 2);
	}
	intersectsWithLine(line) {
		return engine_base_MathUtils.lineToLineIntersection(this,line);
	}
}
engine_base_geometry_Line.__name__ = true;
Object.assign(engine_base_geometry_Line.prototype, {
	__class__: engine_base_geometry_Line
});
class engine_base_geometry_Point {
	constructor(x,y) {
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		this.x = x;
		this.y = y;
	}
	distanceSq(p) {
		let dx = this.x - p.x;
		let dy = this.y - p.y;
		return dx * dx + dy * dy;
	}
	distance(p) {
		let dx = this.x - p.x;
		let dy = this.y - p.y;
		return Math.sqrt(dx * dx + dy * dy);
	}
}
engine_base_geometry_Point.__name__ = true;
Object.assign(engine_base_geometry_Point.prototype, {
	__class__: engine_base_geometry_Point
});
class engine_base_geometry_Rectangle {
	constructor(x,y,w,h,r) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.r = r;
	}
	updatePosition(x,y,r) {
		this.x = x;
		this.y = y;
		this.r = r;
	}
	getCenter() {
		return new engine_base_geometry_Point(this.x,this.y);
	}
	getMaxSide() {
		if(this.w > this.h) {
			return this.w;
		} else {
			return this.h;
		}
	}
	getLeft() {
		return this.x - this.w / 2;
	}
	getRight() {
		return this.x + this.w / 2;
	}
	getTop() {
		return this.y - this.h / 2;
	}
	getBottom() {
		return this.y + this.h / 2;
	}
	getTopLeftPoint() {
		let rotatedCoords = engine_base_MathUtils.rotatePointAroundCenter(this.getLeft(),this.getTop(),this.x,this.y,this.r);
		return new engine_base_geometry_Point(rotatedCoords.x,rotatedCoords.y);
	}
	getBottomLeftPoint() {
		let rotatedCoords = engine_base_MathUtils.rotatePointAroundCenter(this.getLeft(),this.getBottom(),this.x,this.y,this.r);
		return new engine_base_geometry_Point(rotatedCoords.x,rotatedCoords.y);
	}
	getTopRightPoint() {
		let rotatedCoords = engine_base_MathUtils.rotatePointAroundCenter(this.getRight(),this.getTop(),this.x,this.y,this.r);
		return new engine_base_geometry_Point(rotatedCoords.x,rotatedCoords.y);
	}
	getBottomRightPoint() {
		let rotatedCoords = engine_base_MathUtils.rotatePointAroundCenter(this.getRight(),this.getBottom(),this.x,this.y,this.r);
		return new engine_base_geometry_Point(rotatedCoords.x,rotatedCoords.y);
	}
	getLines() {
		let topLeftPoint = this.getTopLeftPoint();
		let bottomLeftPoint = this.getBottomLeftPoint();
		let topRightPoint = this.getTopRightPoint();
		let bottomRightPoint = this.getBottomRightPoint();
		return { lineA : new engine_base_geometry_Line(topLeftPoint.x,topLeftPoint.y,topRightPoint.x,topRightPoint.y), lineB : new engine_base_geometry_Line(topRightPoint.x,topRightPoint.y,bottomRightPoint.x,bottomRightPoint.y), lineC : new engine_base_geometry_Line(bottomRightPoint.x,bottomRightPoint.y,bottomLeftPoint.x,bottomLeftPoint.y), lineD : new engine_base_geometry_Line(bottomLeftPoint.x,bottomLeftPoint.y,topLeftPoint.x,topLeftPoint.y)};
	}
	containsRect(b) {
		let result = true;
		if(this.getLeft() >= b.getRight() || b.getLeft() >= this.getRight()) {
			result = false;
		}
		if(this.getTop() >= b.getBottom() || b.getTop() >= this.getBottom()) {
			result = false;
		}
		return result;
	}
	containtPoint(p) {
		if(this.getLeft() <= p.x && this.getRight() >= p.x && this.getTop() <= p.y) {
			return this.getBottom() >= p.y;
		} else {
			return false;
		}
	}
	intersectsWithLine(line) {
		let lines = this.getLines();
		if(lines.lineA.intersectsWithLine(line)) {
			return true;
		} else if(lines.lineB.intersectsWithLine(line)) {
			return true;
		} else if(lines.lineC.intersectsWithLine(line)) {
			return true;
		} else if(lines.lineD.intersectsWithLine(line)) {
			return true;
		}
		return false;
	}
	intersectsWithPoint(point) {
		if(this.r == 0) {
			if(Math.abs(this.x - point.x) < this.w / 2) {
				return Math.abs(this.y - point.y) < this.h / 2;
			} else {
				return false;
			}
		}
		let tx = Math.cos(this.r) * point.x - Math.sin(this.r) * point.y;
		let ty = Math.cos(this.r) * point.y + Math.sin(this.r) * point.x;
		let cx = Math.cos(this.r) * this.x - Math.sin(this.r) * this.y;
		let cy = Math.cos(this.r) * this.y + Math.sin(this.r) * this.x;
		if(Math.abs(cx - tx) < this.w / 2) {
			return Math.abs(cy - ty) < this.h / 2;
		} else {
			return false;
		}
	}
	intersectsWithRect(b) {
		if(this.r == 0 && b.r == 0) {
			return this.containsRect(b);
		} else {
			let rA = this.getLines();
			let rB = b.getLines();
			if(rA.lineA.intersectsWithLine(rB.lineA) || rA.lineA.intersectsWithLine(rB.lineB) || rA.lineA.intersectsWithLine(rB.lineC) || rA.lineA.intersectsWithLine(rB.lineD)) {
				return true;
			}
			if(rA.lineB.intersectsWithLine(rB.lineA) || rA.lineB.intersectsWithLine(rB.lineB) || rA.lineB.intersectsWithLine(rB.lineC) || rA.lineB.intersectsWithLine(rB.lineD)) {
				return true;
			}
			if(rA.lineC.intersectsWithLine(rB.lineA) || rA.lineC.intersectsWithLine(rB.lineB) || rA.lineC.intersectsWithLine(rB.lineC) || rA.lineC.intersectsWithLine(rB.lineD)) {
				return true;
			}
			if(rA.lineD.intersectsWithLine(rB.lineA) || rA.lineD.intersectsWithLine(rB.lineB) || rA.lineD.intersectsWithLine(rB.lineC) || rA.lineD.intersectsWithLine(rB.lineD)) {
				return true;
			}
			return false;
		}
	}
}
engine_base_geometry_Rectangle.__name__ = true;
Object.assign(engine_base_geometry_Rectangle.prototype, {
	__class__: engine_base_geometry_Rectangle
});
class engine_holy_HolyGameEngine extends engine_base_core_BaseEngine {
	constructor(engineMode) {
		engine_base_core_BaseEngine._hx_skip_constructor = true;
		super();
		engine_base_core_BaseEngine._hx_skip_constructor = false;
		this._hx_constructor(engineMode);
	}
	_hx_constructor(engineMode) {
		if(engineMode == null) {
			engineMode = engine_base_core_EngineMode.Server;
		}
		this.timePassed = 0.0;
		this.framesPassed = 0;
		super._hx_constructor(engineMode,new engine_holy_entity_manager_HolyEntityManager());
	}
	buildEngineEntityFromMinimalStruct(struct) {
		this.createMainEntity(engine_holy_entity_factory_HolyEntityFactory.InitiateEntity(struct.id,struct.ownerId,struct.x,struct.y,struct.entityType),true);
	}
	processInputCommands(playerInputCommands) {
		let _g = 0;
		while(_g < playerInputCommands.length) {
			let i = playerInputCommands[_g];
			++_g;
			let input = js_Boot.__cast(i.playerInputCommand , engine_base_PlayerInputCommand);
			let inputInitiator = input.playerId;
			let entityId = this.playerToEntityMap.h[inputInitiator];
			let entity = js_Boot.__cast(this.mainEntityManager.getEntityById(entityId) , engine_holy_entity_base_HolyBaseEntity);
			if(entity == null || entity.getOwnerId() != inputInitiator) {
				continue;
			}
			this.validatedInputCommands.push(input);
			if(input.inputType == 2 || input.inputType == 3 || input.inputType == 4) {
				entity.markForAction(input.inputType,2);
			} else {
				entity.performMove(input);
			}
		}
	}
	engineLoopUpdate(dt) {
		let beginTime = Date.now();
		this.framesPassed++;
		this.timePassed += dt;
		let entityActionCallbacks = [];
		let jsIterator = this.mainEntityManager.entities.values();
		let _g_jsIterator = jsIterator;
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = _g_jsIterator.next();
			let entity = v;
			if(entity.isAlive) {
				if(entity.getEntityType() == 4) {
					let targetPlayer = this.getNearestPlayer(entity);
					if(targetPlayer != null) {
						entity.setTargetObject(targetPlayer);
					}
				}
				entity.update(dt);
				if(entity.isActing) {
					let hurtEntities = [];
					let deadEntities = [];
					let jsIterator = this.mainEntityManager.entities.values();
					let _g_jsIterator = jsIterator;
					let _g_lastStep = jsIterator.next();
					while(!_g_lastStep.done) {
						let v = _g_lastStep.value;
						_g_lastStep = _g_jsIterator.next();
						let entity2 = v;
						if(entity2.isAlive && entity.getId() != entity2.getId()) {
							if(entity.getCurrentActionRect().containsRect(entity2.getBodyRectangle())) {
								let health = entity2.subtractHealth(entity.actionToPerform.damage);
								if(health == 0) {
									entity2.isAlive = false;
									deadEntities.push(entity2.getId());
									this.removeMainEntity(entity2.getId());
								} else {
									hurtEntities.push(entity2.getId());
								}
							}
						}
					}
					entityActionCallbacks.push({ entityId : entity.getId(), actionType : entity.actionToPerform.actionType, shape : entity.actionToPerform.shape, hurtEntities : hurtEntities, deadEntities : deadEntities});
					entity.isActing = false;
				}
				entity.isRunning = false;
				entity.isWalking = false;
			}
		}
		if(this.entityActionCallback != null && entityActionCallbacks.length > 0) {
			this.entityActionCallback(entityActionCallbacks);
		}
		this.recentEngineLoopTime = Date.now() - beginTime;
	}
	getNearestPlayer(entity) {
		let nearestPlayer = null;
		let nearestPlayerDistance = 0.0;
		let jsIterator = this.mainEntityManager.entities.values();
		let _g_jsIterator = jsIterator;
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = _g_jsIterator.next();
			let targetEntity = v;
			if(targetEntity.getEntityType() == 1) {
				let _this = entity.getBodyRectangle().getCenter();
				let p = targetEntity.getBodyRectangle().getCenter();
				let dx = _this.x - p.x;
				let dy = _this.y - p.y;
				let dist = Math.sqrt(dx * dx + dy * dy);
				if(nearestPlayer == null || dist < nearestPlayerDistance) {
					nearestPlayer = targetEntity;
					nearestPlayerDistance = dist;
				}
			}
		}
		return nearestPlayer;
	}
	customDestroy() {
		this.entityActionCallback = null;
	}
	static main() {
	}
}
$hx_exports["engine"]["holy"]["HolyGameEngine"] = engine_holy_HolyGameEngine;
engine_holy_HolyGameEngine.__name__ = true;
engine_holy_HolyGameEngine.__super__ = engine_base_core_BaseEngine;
Object.assign(engine_holy_HolyGameEngine.prototype, {
	__class__: engine_holy_HolyGameEngine
});
class engine_holy_entity_base_HolyBaseEntity extends engine_base_entity_EngineBaseGameEntity {
	constructor(baseObjectEntity) {
		super(baseObjectEntity);
	}
	performMove(playerInput) {
		this.setRotation(playerInput.movAngle);
		this.determenisticMove();
	}
	markForAction(playerInputType,side) {
		this.isActing = true;
	}
	canPerformMove(playerInputType) {
		return true;
	}
	canPerformAction(playerInputType) {
		if(playerInputType == 4 && this.baseObjectEntity.entityType != 1 || playerInputType == 3 && this.baseObjectEntity.entityType == 1) {
			return false;
		}
		return true;
	}
	updateHashImpl() {
		let e = this.baseObjectEntity;
		let s = e.id + e.x + e.y + e.health;
		return engine_base_EngineUtils.HashString(s);
	}
}
engine_holy_entity_base_HolyBaseEntity.__name__ = true;
engine_holy_entity_base_HolyBaseEntity.__super__ = engine_base_entity_EngineBaseGameEntity;
Object.assign(engine_holy_entity_base_HolyBaseEntity.prototype, {
	__class__: engine_holy_entity_base_HolyBaseEntity
});
class engine_holy_entity_factory_HolyEntityFactory {
	static InitiateEntity(id,ownerId,x,y,entityType) {
		let entity = null;
		switch(entityType) {
		case 1:
			entity = new engine_holy_entity_impl_HolyKnightEntity(engine_holy_entity_impl_HolyKnightEntity.GenerateObjectEntity(id,ownerId,x,y));
			break;
		case 2:
			entity = new engine_holy_entity_impl_HolySamuraiEntity(engine_holy_entity_impl_HolySamuraiEntity.GenerateObjectEntity(id,ownerId,x,y));
			break;
		case 4:
			entity = new engine_holy_entity_impl_HolySkeletonWarriorEntity(engine_holy_entity_impl_HolySkeletonWarriorEntity.GenerateObjectEntity(id,ownerId,x,y));
			break;
		case 5:
			entity = new engine_holy_entity_impl_HolySkeletonArcherEntity(engine_holy_entity_impl_HolySkeletonArcherEntity.GenerateObjectEntity(id,ownerId,x,y));
			break;
		default:
		}
		return entity;
	}
}
engine_holy_entity_factory_HolyEntityFactory.__name__ = true;
class engine_holy_entity_impl_HolyKnightEntity extends engine_holy_entity_base_HolyBaseEntity {
	constructor(baseObjectEntity) {
		super(baseObjectEntity);
	}
	static GenerateObjectEntity(id,ownerId,x,y) {
		return new engine_base_BaseObjectEntity({ x : x, y : y, entityType : 1, entityShape : new engine_base_EntityShape(64,64,32,100), id : id, ownerId : ownerId, health : 100, dodgeChance : 0, entityMovementStruct : engine_holy_entity_impl_HolyKnightEntity.GetMovementStruct(), entityActionStruct : engine_holy_entity_impl_HolyKnightEntity.GetActionsStruct()});
	}
	static GetMovementStruct() {
		let movement = { canWalk : true, canRun : false, walkSpeed : 10, runSpeed : 0, movementDelay : 0.100, vitality : 100, vitalityConsumptionPerSec : 20, vitalityRegenPerSec : 10};
		return movement;
	}
	static GetActionsStruct() {
		let actions = [];
		actions.push({ actionType : 1, damage : 5, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		actions.push({ actionType : 2, damage : 5, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		actions.push({ actionType : 3, damage : 5, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		actions.push({ actionType : 4, damage : 10, aoe : false, penetration : true, shape : new engine_base_EntityShape(10,10), inputDelay : 3});
		actions.push({ actionType : 7, damage : 0, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 3});
		return actions;
	}
}
engine_holy_entity_impl_HolyKnightEntity.__name__ = true;
engine_holy_entity_impl_HolyKnightEntity.__super__ = engine_holy_entity_base_HolyBaseEntity;
Object.assign(engine_holy_entity_impl_HolyKnightEntity.prototype, {
	__class__: engine_holy_entity_impl_HolyKnightEntity
});
class engine_holy_entity_impl_HolySamuraiEntity extends engine_holy_entity_base_HolyBaseEntity {
	constructor(baseObjectEntity) {
		super(baseObjectEntity);
	}
	static GenerateObjectEntity(id,ownerId,x,y) {
		return new engine_base_BaseObjectEntity({ x : x, y : y, entityType : 2, entityShape : new engine_base_EntityShape(64,64,64,100), id : id, ownerId : ownerId, health : 100, dodgeChance : 0, entityMovementStruct : engine_holy_entity_impl_HolySamuraiEntity.GetMovementStruct(), entityActionStruct : engine_holy_entity_impl_HolySamuraiEntity.GetActionsStruct()});
	}
	static GetMovementStruct() {
		let movement = { canWalk : true, canRun : true, walkSpeed : 10, runSpeed : 20, movementDelay : 0.100, vitality : 100, vitalityConsumptionPerSec : 20, vitalityRegenPerSec : 10};
		return movement;
	}
	static GetActionsStruct() {
		let actions = [];
		actions.push({ actionType : 1, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 1});
		actions.push({ actionType : 2, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 1});
		actions.push({ actionType : 3, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 1});
		actions.push({ actionType : 5, damage : 10, aoe : false, penetration : true, shape : new engine_base_EntityShape(10,10), inputDelay : 3});
		return actions;
	}
}
engine_holy_entity_impl_HolySamuraiEntity.__name__ = true;
engine_holy_entity_impl_HolySamuraiEntity.__super__ = engine_holy_entity_base_HolyBaseEntity;
Object.assign(engine_holy_entity_impl_HolySamuraiEntity.prototype, {
	__class__: engine_holy_entity_impl_HolySamuraiEntity
});
class engine_holy_entity_impl_HolySkeletonArcherEntity extends engine_holy_entity_base_HolyBaseEntity {
	constructor(baseObjectEntity) {
		super(baseObjectEntity);
	}
	static GenerateObjectEntity(id,ownerId,x,y) {
		return new engine_base_BaseObjectEntity({ x : x, y : y, entityType : 5, entityShape : new engine_base_EntityShape(64,64,32,100), id : id, ownerId : ownerId, health : 100, dodgeChance : 20, entityMovementStruct : engine_holy_entity_impl_HolySkeletonArcherEntity.GetMovementStruct(), entityActionStruct : engine_holy_entity_impl_HolySkeletonArcherEntity.GetActionsStruct()});
	}
	static GetMovementStruct() {
		let movement = { canWalk : true, canRun : false, walkSpeed : 10, runSpeed : 0, movementDelay : 0.100, vitality : 0, vitalityConsumptionPerSec : 0, vitalityRegenPerSec : 0};
		return movement;
	}
	static GetActionsStruct() {
		let actions = [];
		actions.push({ actionType : 1, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 1});
		actions.push({ actionType : 2, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 1});
		actions.push({ actionType : 3, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(100,100), inputDelay : 1});
		actions.push({ actionType : 5, damage : 10, aoe : false, penetration : true, shape : new engine_base_EntityShape(10,10), inputDelay : 3});
		actions.push({ actionType : 6, damage : 10, aoe : false, penetration : true, shape : new engine_base_EntityShape(10,10), inputDelay : 3});
		return actions;
	}
}
engine_holy_entity_impl_HolySkeletonArcherEntity.__name__ = true;
engine_holy_entity_impl_HolySkeletonArcherEntity.__super__ = engine_holy_entity_base_HolyBaseEntity;
Object.assign(engine_holy_entity_impl_HolySkeletonArcherEntity.prototype, {
	__class__: engine_holy_entity_impl_HolySkeletonArcherEntity
});
class engine_holy_entity_impl_HolySkeletonWarriorEntity extends engine_holy_entity_base_HolyBaseEntity {
	constructor(baseObjectEntity) {
		super(baseObjectEntity);
	}
	static GenerateObjectEntity(id,ownerId,x,y) {
		return new engine_base_BaseObjectEntity({ x : x, y : y, entityType : 4, entityShape : new engine_base_EntityShape(64,64,64,100), id : id, ownerId : ownerId, health : 10, dodgeChance : 0, entityMovementStruct : engine_holy_entity_impl_HolySkeletonWarriorEntity.GetMovementStruct(), entityActionStruct : engine_holy_entity_impl_HolySkeletonWarriorEntity.GetActionsStruct()});
	}
	static GetMovementStruct() {
		let movement = { canWalk : true, canRun : true, walkSpeed : 20, runSpeed : 35, movementDelay : 0.100, vitality : 100, vitalityConsumptionPerSec : 20, vitalityRegenPerSec : 10};
		return movement;
	}
	static GetActionsStruct() {
		let actions = [];
		actions.push({ actionType : 1, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		actions.push({ actionType : 2, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		actions.push({ actionType : 3, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		actions.push({ actionType : 4, damage : 10, aoe : true, penetration : false, shape : new engine_base_EntityShape(140,100,80,100), inputDelay : 1});
		return actions;
	}
}
engine_holy_entity_impl_HolySkeletonWarriorEntity.__name__ = true;
engine_holy_entity_impl_HolySkeletonWarriorEntity.__super__ = engine_holy_entity_base_HolyBaseEntity;
Object.assign(engine_holy_entity_impl_HolySkeletonWarriorEntity.prototype, {
	__class__: engine_holy_entity_impl_HolySkeletonWarriorEntity
});
class engine_holy_entity_manager_HolyEntityManager extends engine_base_entity_BaseEntityManager {
	constructor() {
		super();
	}
}
engine_holy_entity_manager_HolyEntityManager.__name__ = true;
engine_holy_entity_manager_HolyEntityManager.__super__ = engine_base_entity_BaseEntityManager;
Object.assign(engine_holy_entity_manager_HolyEntityManager.prototype, {
	__class__: engine_holy_entity_manager_HolyEntityManager
});
class haxe_IMap {
}
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	get_native() {
		return this.__nativeException;
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_Int32 {
	static ucompare(a,b) {
		if(a < 0) {
			if(b < 0) {
				return ~b - ~a | 0;
			} else {
				return 1;
			}
		}
		if(b < 0) {
			return -1;
		} else {
			return a - b | 0;
		}
	}
}
class haxe_Int64 {
	static divMod(dividend,divisor) {
		if(divisor.high == 0) {
			switch(divisor.low) {
			case 0:
				throw haxe_Exception.thrown("divide by zero");
			case 1:
				return { quotient : new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low), modulus : new haxe__$Int64__$_$_$Int64(0,0)};
			}
		}
		let divSign = dividend.high < 0 != divisor.high < 0;
		let modulus;
		if(dividend.high < 0) {
			let high = ~dividend.high;
			let low = ~dividend.low + 1 | 0;
			if(low == 0) {
				let ret = high++;
				high = high | 0;
			}
			modulus = new haxe__$Int64__$_$_$Int64(high,low);
		} else {
			modulus = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
		}
		if(divisor.high < 0) {
			let high = ~divisor.high;
			let low = ~divisor.low + 1 | 0;
			if(low == 0) {
				let ret = high++;
				high = high | 0;
			}
			divisor = new haxe__$Int64__$_$_$Int64(high,low);
		}
		let quotient = new haxe__$Int64__$_$_$Int64(0,0);
		let mask = new haxe__$Int64__$_$_$Int64(0,1);
		while(!(divisor.high < 0)) {
			let v = haxe_Int32.ucompare(divisor.high,modulus.high);
			let cmp = v != 0 ? v : haxe_Int32.ucompare(divisor.low,modulus.low);
			let b = 1;
			b &= 63;
			divisor = b == 0 ? new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low) : b < 32 ? new haxe__$Int64__$_$_$Int64(divisor.high << b | divisor.low >>> 32 - b,divisor.low << b) : new haxe__$Int64__$_$_$Int64(divisor.low << b - 32,0);
			let b1 = 1;
			b1 &= 63;
			mask = b1 == 0 ? new haxe__$Int64__$_$_$Int64(mask.high,mask.low) : b1 < 32 ? new haxe__$Int64__$_$_$Int64(mask.high << b1 | mask.low >>> 32 - b1,mask.low << b1) : new haxe__$Int64__$_$_$Int64(mask.low << b1 - 32,0);
			if(cmp >= 0) {
				break;
			}
		}
		while(true) {
			let b_high = 0;
			let b_low = 0;
			if(!(mask.high != b_high || mask.low != b_low)) {
				break;
			}
			let v = haxe_Int32.ucompare(modulus.high,divisor.high);
			if((v != 0 ? v : haxe_Int32.ucompare(modulus.low,divisor.low)) >= 0) {
				quotient = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
				let high = modulus.high - divisor.high | 0;
				let low = modulus.low - divisor.low | 0;
				if(haxe_Int32.ucompare(modulus.low,divisor.low) < 0) {
					let ret = high--;
					high = high | 0;
				}
				modulus = new haxe__$Int64__$_$_$Int64(high,low);
			}
			let b = 1;
			b &= 63;
			mask = b == 0 ? new haxe__$Int64__$_$_$Int64(mask.high,mask.low) : b < 32 ? new haxe__$Int64__$_$_$Int64(mask.high >>> b,mask.high << 32 - b | mask.low >>> b) : new haxe__$Int64__$_$_$Int64(0,mask.high >>> b - 32);
			let b1 = 1;
			b1 &= 63;
			divisor = b1 == 0 ? new haxe__$Int64__$_$_$Int64(divisor.high,divisor.low) : b1 < 32 ? new haxe__$Int64__$_$_$Int64(divisor.high >>> b1,divisor.high << 32 - b1 | divisor.low >>> b1) : new haxe__$Int64__$_$_$Int64(0,divisor.high >>> b1 - 32);
		}
		if(divSign) {
			let high = ~quotient.high;
			let low = ~quotient.low + 1 | 0;
			if(low == 0) {
				let ret = high++;
				high = high | 0;
			}
			quotient = new haxe__$Int64__$_$_$Int64(high,low);
		}
		if(dividend.high < 0) {
			let high = ~modulus.high;
			let low = ~modulus.low + 1 | 0;
			if(low == 0) {
				let ret = high++;
				high = high | 0;
			}
			modulus = new haxe__$Int64__$_$_$Int64(high,low);
		}
		return { quotient : quotient, modulus : modulus};
	}
}
class haxe__$Int64__$_$_$Int64 {
	constructor(high,low) {
		this.high = high;
		this.low = low;
	}
}
haxe__$Int64__$_$_$Int64.__name__ = true;
Object.assign(haxe__$Int64__$_$_$Int64.prototype, {
	__class__: haxe__$Int64__$_$_$Int64
});
class haxe_Int64Helper {
	static fromFloat(f) {
		if(isNaN(f) || !isFinite(f)) {
			throw haxe_Exception.thrown("Number is NaN or Infinite");
		}
		let noFractions = f - f % 1;
		if(noFractions > 9007199254740991) {
			throw haxe_Exception.thrown("Conversion overflow");
		}
		if(noFractions < -9007199254740991) {
			throw haxe_Exception.thrown("Conversion underflow");
		}
		let result = new haxe__$Int64__$_$_$Int64(0,0);
		let neg = noFractions < 0;
		let rest = neg ? -noFractions : noFractions;
		let i = 0;
		while(rest >= 1) {
			let curr = rest % 2;
			rest /= 2;
			if(curr >= 1) {
				let a_high = 0;
				let a_low = 1;
				let b = i;
				b &= 63;
				let b1 = b == 0 ? new haxe__$Int64__$_$_$Int64(a_high,a_low) : b < 32 ? new haxe__$Int64__$_$_$Int64(a_high << b | a_low >>> 32 - b,a_low << b) : new haxe__$Int64__$_$_$Int64(a_low << b - 32,0);
				let high = result.high + b1.high | 0;
				let low = result.low + b1.low | 0;
				if(haxe_Int32.ucompare(low,result.low) < 0) {
					let ret = high++;
					high = high | 0;
				}
				result = new haxe__$Int64__$_$_$Int64(high,low);
			}
			++i;
		}
		if(neg) {
			let high = ~result.high;
			let low = ~result.low + 1 | 0;
			if(low == 0) {
				let ret = high++;
				high = high | 0;
			}
			result = new haxe__$Int64__$_$_$Int64(high,low);
		}
		return result;
	}
}
haxe_Int64Helper.__name__ = true;
class haxe_Timer {
	constructor(time_ms) {
		let me = this;
		this.id = setInterval(function() {
			me.run();
		},time_ms);
	}
	stop() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	run() {
	}
	static delay(f,time_ms) {
		let t = new haxe_Timer(time_ms);
		t.run = function() {
			t.stop();
			f();
		};
		return t;
	}
}
haxe_Timer.__name__ = true;
Object.assign(haxe_Timer.prototype, {
	__class__: haxe_Timer
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_crypto_Md5 {
	constructor() {
	}
	bitOR(a,b) {
		let lsb = a & 1 | b & 1;
		let msb31 = a >>> 1 | b >>> 1;
		return msb31 << 1 | lsb;
	}
	bitXOR(a,b) {
		let lsb = a & 1 ^ b & 1;
		let msb31 = a >>> 1 ^ b >>> 1;
		return msb31 << 1 | lsb;
	}
	bitAND(a,b) {
		let lsb = a & 1 & (b & 1);
		let msb31 = a >>> 1 & b >>> 1;
		return msb31 << 1 | lsb;
	}
	addme(x,y) {
		let lsw = (x & 65535) + (y & 65535);
		let msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return msw << 16 | lsw & 65535;
	}
	rol(num,cnt) {
		return num << cnt | num >>> 32 - cnt;
	}
	cmn(q,a,b,x,s,t) {
		return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b);
	}
	ff(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t);
	}
	gg(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t);
	}
	hh(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t);
	}
	ii(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t);
	}
	doEncode(x) {
		let a = 1732584193;
		let b = -271733879;
		let c = -1732584194;
		let d = 271733878;
		let step;
		let i = 0;
		while(i < x.length) {
			let olda = a;
			let oldb = b;
			let oldc = c;
			let oldd = d;
			step = 0;
			a = this.ff(a,b,c,d,x[i],7,-680876936);
			d = this.ff(d,a,b,c,x[i + 1],12,-389564586);
			c = this.ff(c,d,a,b,x[i + 2],17,606105819);
			b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);
			a = this.ff(a,b,c,d,x[i + 4],7,-176418897);
			d = this.ff(d,a,b,c,x[i + 5],12,1200080426);
			c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);
			b = this.ff(b,c,d,a,x[i + 7],22,-45705983);
			a = this.ff(a,b,c,d,x[i + 8],7,1770035416);
			d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);
			c = this.ff(c,d,a,b,x[i + 10],17,-42063);
			b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);
			a = this.ff(a,b,c,d,x[i + 12],7,1804603682);
			d = this.ff(d,a,b,c,x[i + 13],12,-40341101);
			c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);
			b = this.ff(b,c,d,a,x[i + 15],22,1236535329);
			a = this.gg(a,b,c,d,x[i + 1],5,-165796510);
			d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);
			c = this.gg(c,d,a,b,x[i + 11],14,643717713);
			b = this.gg(b,c,d,a,x[i],20,-373897302);
			a = this.gg(a,b,c,d,x[i + 5],5,-701558691);
			d = this.gg(d,a,b,c,x[i + 10],9,38016083);
			c = this.gg(c,d,a,b,x[i + 15],14,-660478335);
			b = this.gg(b,c,d,a,x[i + 4],20,-405537848);
			a = this.gg(a,b,c,d,x[i + 9],5,568446438);
			d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);
			c = this.gg(c,d,a,b,x[i + 3],14,-187363961);
			b = this.gg(b,c,d,a,x[i + 8],20,1163531501);
			a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);
			d = this.gg(d,a,b,c,x[i + 2],9,-51403784);
			c = this.gg(c,d,a,b,x[i + 7],14,1735328473);
			b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);
			a = this.hh(a,b,c,d,x[i + 5],4,-378558);
			d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);
			c = this.hh(c,d,a,b,x[i + 11],16,1839030562);
			b = this.hh(b,c,d,a,x[i + 14],23,-35309556);
			a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);
			d = this.hh(d,a,b,c,x[i + 4],11,1272893353);
			c = this.hh(c,d,a,b,x[i + 7],16,-155497632);
			b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);
			a = this.hh(a,b,c,d,x[i + 13],4,681279174);
			d = this.hh(d,a,b,c,x[i],11,-358537222);
			c = this.hh(c,d,a,b,x[i + 3],16,-722521979);
			b = this.hh(b,c,d,a,x[i + 6],23,76029189);
			a = this.hh(a,b,c,d,x[i + 9],4,-640364487);
			d = this.hh(d,a,b,c,x[i + 12],11,-421815835);
			c = this.hh(c,d,a,b,x[i + 15],16,530742520);
			b = this.hh(b,c,d,a,x[i + 2],23,-995338651);
			a = this.ii(a,b,c,d,x[i],6,-198630844);
			d = this.ii(d,a,b,c,x[i + 7],10,1126891415);
			c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);
			b = this.ii(b,c,d,a,x[i + 5],21,-57434055);
			a = this.ii(a,b,c,d,x[i + 12],6,1700485571);
			d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);
			c = this.ii(c,d,a,b,x[i + 10],15,-1051523);
			b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);
			a = this.ii(a,b,c,d,x[i + 8],6,1873313359);
			d = this.ii(d,a,b,c,x[i + 15],10,-30611744);
			c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);
			b = this.ii(b,c,d,a,x[i + 13],21,1309151649);
			a = this.ii(a,b,c,d,x[i + 4],6,-145523070);
			d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);
			c = this.ii(c,d,a,b,x[i + 2],15,718787259);
			b = this.ii(b,c,d,a,x[i + 9],21,-343485551);
			a = this.addme(a,olda);
			b = this.addme(b,oldb);
			c = this.addme(c,oldc);
			d = this.addme(d,oldd);
			i += 16;
		}
		return [a,b,c,d];
	}
	static make(b) {
		let h = new haxe_crypto_Md5().doEncode(haxe_crypto_Md5.bytes2blks(b));
		let out = new haxe_io_Bytes(new ArrayBuffer(16));
		let p = 0;
		out.b[p++] = h[0] & 255;
		out.b[p++] = h[0] >> 8 & 255;
		out.b[p++] = h[0] >> 16 & 255;
		out.b[p++] = h[0] >>> 24;
		out.b[p++] = h[1] & 255;
		out.b[p++] = h[1] >> 8 & 255;
		out.b[p++] = h[1] >> 16 & 255;
		out.b[p++] = h[1] >>> 24;
		out.b[p++] = h[2] & 255;
		out.b[p++] = h[2] >> 8 & 255;
		out.b[p++] = h[2] >> 16 & 255;
		out.b[p++] = h[2] >>> 24;
		out.b[p++] = h[3] & 255;
		out.b[p++] = h[3] >> 8 & 255;
		out.b[p++] = h[3] >> 16 & 255;
		out.b[p++] = h[3] >>> 24;
		return out;
	}
	static bytes2blks(b) {
		let nblk = (b.length + 8 >> 6) + 1;
		let blks = [];
		let blksSize = nblk * 16;
		let _g = 0;
		let _g1 = blksSize;
		while(_g < _g1) {
			let i = _g++;
			blks[i] = 0;
		}
		let i = 0;
		while(i < b.length) {
			blks[i >> 2] |= b.b[i] << (((b.length << 3) + i & 3) << 3);
			++i;
		}
		blks[i >> 2] |= 128 << (b.length * 8 + i) % 4 * 8;
		let l = b.length * 8;
		let k = nblk * 16 - 2;
		blks[k] = l & 255;
		blks[k] |= (l >>> 8 & 255) << 8;
		blks[k] |= (l >>> 16 & 255) << 16;
		blks[k] |= (l >>> 24 & 255) << 24;
		return blks;
	}
}
haxe_crypto_Md5.__name__ = true;
Object.assign(haxe_crypto_Md5.prototype, {
	__class__: haxe_crypto_Md5
});
class haxe_crypto_Sha1 {
	constructor() {
	}
	doEncode(x) {
		let w = [];
		let a = 1732584193;
		let b = -271733879;
		let c = -1732584194;
		let d = 271733878;
		let e = -1009589776;
		let i = 0;
		while(i < x.length) {
			let olda = a;
			let oldb = b;
			let oldc = c;
			let oldd = d;
			let olde = e;
			let j = 0;
			while(j < 80) {
				if(j < 16) {
					w[j] = x[i + j];
				} else {
					let num = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
					w[j] = num << 1 | num >>> 31;
				}
				let t = (a << 5 | a >>> 27) + this.ft(j,b,c,d) + e + w[j] + this.kt(j);
				e = d;
				d = c;
				c = b << 30 | b >>> 2;
				b = a;
				a = t;
				++j;
			}
			a += olda;
			b += oldb;
			c += oldc;
			d += oldd;
			e += olde;
			i += 16;
		}
		return [a,b,c,d,e];
	}
	ft(t,b,c,d) {
		if(t < 20) {
			return b & c | ~b & d;
		}
		if(t < 40) {
			return b ^ c ^ d;
		}
		if(t < 60) {
			return b & c | b & d | c & d;
		}
		return b ^ c ^ d;
	}
	kt(t) {
		if(t < 20) {
			return 1518500249;
		}
		if(t < 40) {
			return 1859775393;
		}
		if(t < 60) {
			return -1894007588;
		}
		return -899497514;
	}
	static make(b) {
		let h = new haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b));
		let out = new haxe_io_Bytes(new ArrayBuffer(20));
		let p = 0;
		out.b[p++] = h[0] >>> 24;
		out.b[p++] = h[0] >> 16 & 255;
		out.b[p++] = h[0] >> 8 & 255;
		out.b[p++] = h[0] & 255;
		out.b[p++] = h[1] >>> 24;
		out.b[p++] = h[1] >> 16 & 255;
		out.b[p++] = h[1] >> 8 & 255;
		out.b[p++] = h[1] & 255;
		out.b[p++] = h[2] >>> 24;
		out.b[p++] = h[2] >> 16 & 255;
		out.b[p++] = h[2] >> 8 & 255;
		out.b[p++] = h[2] & 255;
		out.b[p++] = h[3] >>> 24;
		out.b[p++] = h[3] >> 16 & 255;
		out.b[p++] = h[3] >> 8 & 255;
		out.b[p++] = h[3] & 255;
		out.b[p++] = h[4] >>> 24;
		out.b[p++] = h[4] >> 16 & 255;
		out.b[p++] = h[4] >> 8 & 255;
		out.b[p++] = h[4] & 255;
		return out;
	}
	static bytes2blks(b) {
		let nblk = (b.length + 8 >> 6) + 1;
		let blks = [];
		let _g = 0;
		let _g1 = nblk * 16;
		while(_g < _g1) {
			let i = _g++;
			blks[i] = 0;
		}
		let _g2 = 0;
		let _g3 = b.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let p = i >> 2;
			blks[p] |= b.b[i] << 24 - ((i & 3) << 3);
		}
		let i = b.length;
		let p = i >> 2;
		blks[p] |= 128 << 24 - ((i & 3) << 3);
		blks[nblk * 16 - 1] = b.length * 8;
		return blks;
	}
}
haxe_crypto_Sha1.__name__ = true;
Object.assign(haxe_crypto_Sha1.prototype, {
	__class__: haxe_crypto_Sha1
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	toHex() {
		let s_b = "";
		let chars = [];
		let str = "0123456789abcdef";
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			chars.push(HxOverrides.cca(str,i));
		}
		let _g2 = 0;
		let _g3 = this.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let c = this.b[i];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
	static ofHex(s) {
		if((s.length & 1) != 0) {
			throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
		}
		let a = [];
		let i = 0;
		let len = s.length >> 1;
		while(i < len) {
			let high = s.charCodeAt(i * 2);
			let low = s.charCodeAt(i * 2 + 1);
			high = (high & 15) + ((high & 64) >> 6) * 9;
			low = (low & 15) + ((low & 64) >> 6) * 9;
			a.push((high << 4 | low) & 255);
			++i;
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
}
haxe_io_Bytes.__name__ = true;
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		let intf = cc.__interfaces__;
		if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
			let _g = 0;
			let _g1 = intf.length;
			while(_g < _g1) {
				let i = _g++;
				let i1 = intf[i];
				if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
					return true;
				}
			}
		}
		return js_Boot.__interfLoop(cc.__super__,cl);
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = true;
class uuid_Uuid {
	static splitmix64_seed(index) {
		let b_high = -1640531527;
		let b_low = 2135587861;
		let high = index.high + b_high | 0;
		let low = index.low + b_low | 0;
		if(haxe_Int32.ucompare(low,index.low) < 0) {
			let ret = high++;
			high = high | 0;
		}
		let result = new haxe__$Int64__$_$_$Int64(high,low);
		let b = 30;
		b &= 63;
		let b1 = b == 0 ? new haxe__$Int64__$_$_$Int64(result.high,result.low) : b < 32 ? new haxe__$Int64__$_$_$Int64(result.high >> b,result.high << 32 - b | result.low >>> b) : new haxe__$Int64__$_$_$Int64(result.high >> 31,result.high >> b - 32);
		let a_high = result.high ^ b1.high;
		let a_low = result.low ^ b1.low;
		let b_high1 = -1084733587;
		let b_low1 = 484763065;
		let mask = 65535;
		let al = a_low & mask;
		let ah = a_low >>> 16;
		let bl = b_low1 & mask;
		let bh = b_low1 >>> 16;
		let p00 = haxe_Int32._mul(al,bl);
		let p10 = haxe_Int32._mul(ah,bl);
		let p01 = haxe_Int32._mul(al,bh);
		let p11 = haxe_Int32._mul(ah,bh);
		let low1 = p00;
		let high1 = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
		p01 <<= 16;
		low1 = low1 + p01 | 0;
		if(haxe_Int32.ucompare(low1,p01) < 0) {
			let ret = high1++;
			high1 = high1 | 0;
		}
		p10 <<= 16;
		low1 = low1 + p10 | 0;
		if(haxe_Int32.ucompare(low1,p10) < 0) {
			let ret = high1++;
			high1 = high1 | 0;
		}
		high1 = high1 + (haxe_Int32._mul(a_low,b_high1) + haxe_Int32._mul(a_high,b_low1) | 0) | 0;
		result = new haxe__$Int64__$_$_$Int64(high1,low1);
		let b2 = 27;
		b2 &= 63;
		let b3 = b2 == 0 ? new haxe__$Int64__$_$_$Int64(result.high,result.low) : b2 < 32 ? new haxe__$Int64__$_$_$Int64(result.high >> b2,result.high << 32 - b2 | result.low >>> b2) : new haxe__$Int64__$_$_$Int64(result.high >> 31,result.high >> b2 - 32);
		let a_high1 = result.high ^ b3.high;
		let a_low1 = result.low ^ b3.low;
		let b_high2 = -1798288965;
		let b_low2 = 321982955;
		let mask1 = 65535;
		let al1 = a_low1 & mask1;
		let ah1 = a_low1 >>> 16;
		let bl1 = b_low2 & mask1;
		let bh1 = b_low2 >>> 16;
		let p001 = haxe_Int32._mul(al1,bl1);
		let p101 = haxe_Int32._mul(ah1,bl1);
		let p011 = haxe_Int32._mul(al1,bh1);
		let p111 = haxe_Int32._mul(ah1,bh1);
		let low2 = p001;
		let high2 = (p111 + (p011 >>> 16) | 0) + (p101 >>> 16) | 0;
		p011 <<= 16;
		low2 = low2 + p011 | 0;
		if(haxe_Int32.ucompare(low2,p011) < 0) {
			let ret = high2++;
			high2 = high2 | 0;
		}
		p101 <<= 16;
		low2 = low2 + p101 | 0;
		if(haxe_Int32.ucompare(low2,p101) < 0) {
			let ret = high2++;
			high2 = high2 | 0;
		}
		high2 = high2 + (haxe_Int32._mul(a_low1,b_high2) + haxe_Int32._mul(a_high1,b_low2) | 0) | 0;
		result = new haxe__$Int64__$_$_$Int64(high2,low2);
		let b4 = 31;
		b4 &= 63;
		let b5 = b4 == 0 ? new haxe__$Int64__$_$_$Int64(result.high,result.low) : b4 < 32 ? new haxe__$Int64__$_$_$Int64(result.high >> b4,result.high << 32 - b4 | result.low >>> b4) : new haxe__$Int64__$_$_$Int64(result.high >> 31,result.high >> b4 - 32);
		return new haxe__$Int64__$_$_$Int64(result.high ^ b5.high,result.low ^ b5.low);
	}
	static randomFromRange(min,max) {
		let s1 = uuid_Uuid.state0;
		let s0 = uuid_Uuid.state1;
		uuid_Uuid.state0 = s0;
		let b = 23;
		b &= 63;
		let b1 = b == 0 ? new haxe__$Int64__$_$_$Int64(s1.high,s1.low) : b < 32 ? new haxe__$Int64__$_$_$Int64(s1.high << b | s1.low >>> 32 - b,s1.low << b) : new haxe__$Int64__$_$_$Int64(s1.low << b - 32,0);
		s1 = new haxe__$Int64__$_$_$Int64(s1.high ^ b1.high,s1.low ^ b1.low);
		let a_high = s1.high ^ s0.high;
		let a_low = s1.low ^ s0.low;
		let b2 = 18;
		b2 &= 63;
		let b3 = b2 == 0 ? new haxe__$Int64__$_$_$Int64(s1.high,s1.low) : b2 < 32 ? new haxe__$Int64__$_$_$Int64(s1.high >>> b2,s1.high << 32 - b2 | s1.low >>> b2) : new haxe__$Int64__$_$_$Int64(0,s1.high >>> b2 - 32);
		let a_high1 = a_high ^ b3.high;
		let a_low1 = a_low ^ b3.low;
		let b4 = 5;
		b4 &= 63;
		let b5 = b4 == 0 ? new haxe__$Int64__$_$_$Int64(s0.high,s0.low) : b4 < 32 ? new haxe__$Int64__$_$_$Int64(s0.high >>> b4,s0.high << 32 - b4 | s0.low >>> b4) : new haxe__$Int64__$_$_$Int64(0,s0.high >>> b4 - 32);
		uuid_Uuid.state1 = new haxe__$Int64__$_$_$Int64(a_high1 ^ b5.high,a_low1 ^ b5.low);
		let a = uuid_Uuid.state1;
		let high = a.high + s0.high | 0;
		let low = a.low + s0.low | 0;
		if(haxe_Int32.ucompare(low,a.low) < 0) {
			let ret = high++;
			high = high | 0;
		}
		let x = max - min + 1;
		let result = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high,low),new haxe__$Int64__$_$_$Int64(x >> 31,x)).modulus.low;
		if(result < 0) {
			result = -result;
		}
		return result + min;
	}
	static randomByte() {
		return uuid_Uuid.randomFromRange(0,255);
	}
	static fromShort(shortUuid,separator,fromAlphabet) {
		if(fromAlphabet == null) {
			fromAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(separator == null) {
			separator = "-";
		}
		let uuid = uuid_Uuid.convert(shortUuid,fromAlphabet,"0123456789abcdef");
		return uuid_Uuid.hexToUuid(uuid,separator);
	}
	static toShort(uuid,separator,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(separator == null) {
			separator = "-";
		}
		uuid = StringTools.replace(uuid,separator,"").toLowerCase();
		return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet);
	}
	static fromNano(nanoUuid,separator,fromAlphabet) {
		if(fromAlphabet == null) {
			fromAlphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
		}
		if(separator == null) {
			separator = "-";
		}
		let uuid = uuid_Uuid.convert(nanoUuid,fromAlphabet,"0123456789abcdef");
		return uuid_Uuid.hexToUuid(uuid,separator);
	}
	static toNano(uuid,separator,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
		}
		if(separator == null) {
			separator = "-";
		}
		uuid = StringTools.replace(uuid,separator,"").toLowerCase();
		return uuid_Uuid.convert(uuid,"0123456789abcdef",toAlphabet);
	}
	static v1(node,optClockSequence,msecs,optNsecs,randomFunc,separator,shortUuid,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(shortUuid == null) {
			shortUuid = false;
		}
		if(separator == null) {
			separator = "-";
		}
		if(optNsecs == null) {
			optNsecs = -1;
		}
		if(msecs == null) {
			msecs = -1;
		}
		if(optClockSequence == null) {
			optClockSequence = -1;
		}
		if(randomFunc == null) {
			randomFunc = uuid_Uuid.randomByte;
		}
		let buffer = new haxe_io_Bytes(new ArrayBuffer(16));
		if(node == null) {
			node = new haxe_io_Bytes(new ArrayBuffer(6));
			let v = randomFunc();
			node.b[0] = v;
			let v1 = randomFunc();
			node.b[1] = v1;
			let v2 = randomFunc();
			node.b[2] = v2;
			let v3 = randomFunc();
			node.b[3] = v3;
			let v4 = randomFunc();
			node.b[4] = v4;
			let v5 = randomFunc();
			node.b[5] = v5;
			node.b[0] |= 1;
		}
		if(uuid_Uuid.clockSequenceBuffer == -1) {
			uuid_Uuid.clockSequenceBuffer = (randomFunc() << 8 | randomFunc()) & 16383;
		}
		let clockSeq = optClockSequence;
		if(optClockSequence == -1) {
			clockSeq = uuid_Uuid.clockSequenceBuffer;
		}
		if(msecs == -1) {
			msecs = Math.round(Date.now());
		}
		let nsecs = optNsecs;
		if(optNsecs == -1) {
			nsecs = uuid_Uuid.lastNSecs + 1;
		}
		let dt = msecs - uuid_Uuid.lastMSecs + (nsecs - uuid_Uuid.lastNSecs) / 10000;
		if(dt < 0 && optClockSequence == -1) {
			clockSeq = clockSeq + 1 & 16383;
		}
		if((dt < 0 || msecs > uuid_Uuid.lastMSecs) && optNsecs == -1) {
			nsecs = 0;
		}
		if(nsecs >= 10000) {
			throw haxe_Exception.thrown("Can't create more than 10M uuids/sec");
		}
		uuid_Uuid.lastMSecs = msecs;
		uuid_Uuid.lastNSecs = nsecs;
		uuid_Uuid.clockSequenceBuffer = clockSeq;
		msecs += 12219292800000;
		let imsecs = haxe_Int64Helper.fromFloat(msecs);
		let b_high = 0;
		let b_low = 268435455;
		let a_high = imsecs.high & b_high;
		let a_low = imsecs.low & b_low;
		let b_high1 = 0;
		let b_low1 = 10000;
		let mask = 65535;
		let al = a_low & mask;
		let ah = a_low >>> 16;
		let bl = b_low1 & mask;
		let bh = b_low1 >>> 16;
		let p00 = haxe_Int32._mul(al,bl);
		let p10 = haxe_Int32._mul(ah,bl);
		let p01 = haxe_Int32._mul(al,bh);
		let p11 = haxe_Int32._mul(ah,bh);
		let low = p00;
		let high = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
		p01 <<= 16;
		low = low + p01 | 0;
		if(haxe_Int32.ucompare(low,p01) < 0) {
			let ret = high++;
			high = high | 0;
		}
		p10 <<= 16;
		low = low + p10 | 0;
		if(haxe_Int32.ucompare(low,p10) < 0) {
			let ret = high++;
			high = high | 0;
		}
		high = high + (haxe_Int32._mul(a_low,b_high1) + haxe_Int32._mul(a_high,b_low1) | 0) | 0;
		let a_high1 = high;
		let a_low1 = low;
		let b_high2 = nsecs >> 31;
		let b_low2 = nsecs;
		let high1 = a_high1 + b_high2 | 0;
		let low1 = a_low1 + b_low2 | 0;
		if(haxe_Int32.ucompare(low1,a_low1) < 0) {
			let ret = high1++;
			high1 = high1 | 0;
		}
		let tl = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high1,low1),uuid_Uuid.DVS).modulus.low;
		buffer.b[0] = tl >>> 24 & 255;
		buffer.b[1] = tl >>> 16 & 255;
		buffer.b[2] = tl >>> 8 & 255;
		buffer.b[3] = tl & 255;
		let a = haxe_Int64.divMod(imsecs,uuid_Uuid.DVS).quotient;
		let b_high3 = 0;
		let b_low3 = 10000;
		let mask1 = 65535;
		let al1 = a.low & mask1;
		let ah1 = a.low >>> 16;
		let bl1 = b_low3 & mask1;
		let bh1 = b_low3 >>> 16;
		let p001 = haxe_Int32._mul(al1,bl1);
		let p101 = haxe_Int32._mul(ah1,bl1);
		let p011 = haxe_Int32._mul(al1,bh1);
		let p111 = haxe_Int32._mul(ah1,bh1);
		let low2 = p001;
		let high2 = (p111 + (p011 >>> 16) | 0) + (p101 >>> 16) | 0;
		p011 <<= 16;
		low2 = low2 + p011 | 0;
		if(haxe_Int32.ucompare(low2,p011) < 0) {
			let ret = high2++;
			high2 = high2 | 0;
		}
		p101 <<= 16;
		low2 = low2 + p101 | 0;
		if(haxe_Int32.ucompare(low2,p101) < 0) {
			let ret = high2++;
			high2 = high2 | 0;
		}
		high2 = high2 + (haxe_Int32._mul(a.low,b_high3) + haxe_Int32._mul(a.high,b_low3) | 0) | 0;
		let a_high2 = high2;
		let a_low2 = low2;
		let b_high4 = 0;
		let b_low4 = 268435455;
		let this_high = a_high2 & b_high4;
		let this_low = a_low2 & b_low4;
		let tmh = this_low;
		buffer.b[4] = tmh >>> 8 & 255;
		buffer.b[5] = tmh & 255;
		buffer.b[6] = tmh >>> 24 & 15 | 16;
		buffer.b[7] = tmh >>> 16 & 255;
		buffer.b[8] = clockSeq >>> 8 | 128;
		buffer.b[9] = clockSeq & 255;
		buffer.b[10] = node.b[0];
		buffer.b[11] = node.b[1];
		buffer.b[12] = node.b[2];
		buffer.b[13] = node.b[3];
		buffer.b[14] = node.b[4];
		buffer.b[15] = node.b[5];
		let uuid = uuid_Uuid.stringify(buffer,separator);
		if(shortUuid) {
			uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
		}
		return uuid;
	}
	static v3(name,namespace,separator,shortUuid,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(shortUuid == null) {
			shortUuid = false;
		}
		if(separator == null) {
			separator = "-";
		}
		if(namespace == null) {
			namespace = "";
		}
		namespace = StringTools.replace(namespace,"-","");
		let buffer = haxe_crypto_Md5.make(haxe_io_Bytes.ofHex(namespace + haxe_io_Bytes.ofString(name).toHex()));
		buffer.b[6] = buffer.b[6] & 15 | 48;
		buffer.b[8] = buffer.b[8] & 63 | 128;
		let uuid = uuid_Uuid.stringify(buffer,separator);
		if(shortUuid) {
			uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
		}
		return uuid;
	}
	static v4(randBytes,randomFunc,separator,shortUuid,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(shortUuid == null) {
			shortUuid = false;
		}
		if(separator == null) {
			separator = "-";
		}
		if(randomFunc == null) {
			randomFunc = uuid_Uuid.randomByte;
		}
		let buffer = randBytes;
		if(buffer == null) {
			buffer = new haxe_io_Bytes(new ArrayBuffer(16));
			let v = randomFunc();
			buffer.b[0] = v;
			let v1 = randomFunc();
			buffer.b[1] = v1;
			let v2 = randomFunc();
			buffer.b[2] = v2;
			let v3 = randomFunc();
			buffer.b[3] = v3;
			let v4 = randomFunc();
			buffer.b[4] = v4;
			let v5 = randomFunc();
			buffer.b[5] = v5;
			let v6 = randomFunc();
			buffer.b[6] = v6;
			let v7 = randomFunc();
			buffer.b[7] = v7;
			let v8 = randomFunc();
			buffer.b[8] = v8;
			let v9 = randomFunc();
			buffer.b[9] = v9;
			let v10 = randomFunc();
			buffer.b[10] = v10;
			let v11 = randomFunc();
			buffer.b[11] = v11;
			let v12 = randomFunc();
			buffer.b[12] = v12;
			let v13 = randomFunc();
			buffer.b[13] = v13;
			let v14 = randomFunc();
			buffer.b[14] = v14;
			let v15 = randomFunc();
			buffer.b[15] = v15;
		} else if(buffer.length < 16) {
			throw haxe_Exception.thrown("Random bytes should be at least 16 bytes");
		}
		buffer.b[6] = buffer.b[6] & 15 | 64;
		buffer.b[8] = buffer.b[8] & 63 | 128;
		let uuid = uuid_Uuid.stringify(buffer,separator);
		if(shortUuid) {
			uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
		}
		return uuid;
	}
	static v5(name,namespace,separator,shortUuid,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(shortUuid == null) {
			shortUuid = false;
		}
		if(separator == null) {
			separator = "-";
		}
		if(namespace == null) {
			namespace = "";
		}
		namespace = StringTools.replace(namespace,"-","");
		let buffer = haxe_crypto_Sha1.make(haxe_io_Bytes.ofHex(namespace + haxe_io_Bytes.ofString(name).toHex()));
		buffer.b[6] = buffer.b[6] & 15 | 80;
		buffer.b[8] = buffer.b[8] & 63 | 128;
		let uuid = uuid_Uuid.stringify(buffer,separator);
		if(shortUuid) {
			uuid = uuid_Uuid.toShort(uuid,separator,toAlphabet);
		}
		return uuid;
	}
	static stringify(data,separator) {
		if(separator == null) {
			separator = "-";
		}
		return uuid_Uuid.hexToUuid(data.toHex(),separator);
	}
	static parse(uuid,separator) {
		if(separator == null) {
			separator = "-";
		}
		return haxe_io_Bytes.ofHex(StringTools.replace(uuid,separator,""));
	}
	static validate(uuid,separator) {
		if(separator == null) {
			separator = "-";
		}
		if(separator == "") {
			uuid = HxOverrides.substr(uuid,0,8) + "-" + HxOverrides.substr(uuid,8,4) + "-" + HxOverrides.substr(uuid,12,4) + "-" + HxOverrides.substr(uuid,16,4) + "-" + HxOverrides.substr(uuid,20,12);
		} else if(separator != "-") {
			uuid = StringTools.replace(uuid,separator,"-");
		}
		return uuid_Uuid.regexp.match(uuid);
	}
	static version(uuid,separator) {
		if(separator == null) {
			separator = "-";
		}
		uuid = StringTools.replace(uuid,separator,"");
		return Std.parseInt("0x" + HxOverrides.substr(uuid,12,1));
	}
	static hexToUuid(hex,separator) {
		return HxOverrides.substr(hex,0,8) + separator + HxOverrides.substr(hex,8,4) + separator + HxOverrides.substr(hex,12,4) + separator + HxOverrides.substr(hex,16,4) + separator + HxOverrides.substr(hex,20,12);
	}
	static convert(number,fromAlphabet,toAlphabet) {
		let fromBase = fromAlphabet.length;
		let toBase = toAlphabet.length;
		let len = number.length;
		let buf = "";
		let numberMap = new Array(len);
		let divide = 0;
		let newlen = 0;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			numberMap[i] = fromAlphabet.indexOf(number.charAt(i));
		}
		do {
			divide = 0;
			newlen = 0;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				divide = divide * fromBase + numberMap[i];
				if(divide >= toBase) {
					numberMap[newlen++] = Math.floor(divide / toBase);
					divide %= toBase;
				} else if(newlen > 0) {
					numberMap[newlen++] = 0;
				}
			}
			len = newlen;
			buf = toAlphabet.charAt(divide) + buf;
		} while(newlen != 0);
		return buf;
	}
	static nanoId(len,alphabet,randomFunc) {
		if(alphabet == null) {
			alphabet = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
		}
		if(len == null) {
			len = 21;
		}
		if(randomFunc == null) {
			randomFunc = uuid_Uuid.randomByte;
		}
		if(alphabet == null) {
			throw haxe_Exception.thrown("Alphabet cannot be null");
		}
		if(alphabet.length == 0 || alphabet.length >= 256) {
			throw haxe_Exception.thrown("Alphabet must contain between 1 and 255 symbols");
		}
		if(len <= 0) {
			throw haxe_Exception.thrown("Length must be greater than zero");
		}
		let mask = (2 << Math.floor(Math.log(alphabet.length - 1) / Math.log(2))) - 1;
		let step = Math.ceil(1.6 * mask * len / alphabet.length);
		let sb_b = "";
		while(sb_b.length != len) {
			let _g = 0;
			let _g1 = step;
			while(_g < _g1) {
				let i = _g++;
				let rnd = randomFunc();
				let aIndex = rnd & mask;
				if(aIndex < alphabet.length) {
					sb_b += Std.string(alphabet.charAt(aIndex));
					if(sb_b.length == len) {
						break;
					}
				}
			}
		}
		return sb_b;
	}
	static short(toAlphabet,randomFunc) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		return uuid_Uuid.v4(null,randomFunc,null,true,toAlphabet);
	}
}
uuid_Uuid.__name__ = true;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
	String.__name__ = true;
	Array.__name__ = true;
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
js_Boot.__toStr = ({ }).toString;
engine_base_core_BaseEngine._hx_skip_constructor = false;
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
uuid_Uuid.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.ISO_OID = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.X500_DN = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";
uuid_Uuid.NIL = "00000000-0000-0000-0000-000000000000";
uuid_Uuid.LOWERCASE_BASE26 = "abcdefghijklmnopqrstuvwxyz";
uuid_Uuid.UPPERCASE_BASE26 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
uuid_Uuid.NO_LOOK_ALIKES_BASE51 = "2346789ABCDEFGHJKLMNPQRTUVWXYZabcdefghijkmnpqrtwxyz";
uuid_Uuid.FLICKR_BASE58 = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
uuid_Uuid.BASE_70 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+!@#$^";
uuid_Uuid.BASE_85 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#";
uuid_Uuid.COOKIE_BASE90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";
uuid_Uuid.NANO_ID_ALPHABET = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
uuid_Uuid.NUMBERS_BIN = "01";
uuid_Uuid.NUMBERS_OCT = "01234567";
uuid_Uuid.NUMBERS_DEC = "0123456789";
uuid_Uuid.NUMBERS_HEX = "0123456789abcdef";
uuid_Uuid.lastMSecs = 0;
uuid_Uuid.lastNSecs = 0;
uuid_Uuid.clockSequenceBuffer = -1;
uuid_Uuid.regexp = new EReg("^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$","i");
uuid_Uuid.rndSeed = haxe_Int64Helper.fromFloat(Date.now());
uuid_Uuid.state0 = uuid_Uuid.splitmix64_seed(uuid_Uuid.rndSeed);
uuid_Uuid.state1 = (function($this) {
	var $r;
	let a = uuid_Uuid.rndSeed;
	let x = Std.random(10000);
	let b_high = x >> 31;
	let b_low = x;
	let high = a.high + b_high | 0;
	let low = a.low + b_low | 0;
	if(haxe_Int32.ucompare(low,a.low) < 0) {
		let ret = high++;
		high = high | 0;
	}
	let a_high = high;
	let a_low = low;
	let b_high1 = 0;
	let b_low1 = 1;
	let high1 = a_high + b_high1 | 0;
	let low1 = a_low + b_low1 | 0;
	if(haxe_Int32.ucompare(low1,a_low) < 0) {
		let ret = high1++;
		high1 = high1 | 0;
	}
	$r = uuid_Uuid.splitmix64_seed(new haxe__$Int64__$_$_$Int64(high1,low1));
	return $r;
}(this));
uuid_Uuid.DVS = new haxe__$Int64__$_$_$Int64(1,0);
engine_holy_HolyGameEngine.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
